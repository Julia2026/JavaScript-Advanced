const Demo = () => {

  /*
    Грунтуючись на розумінні лексичного оточення, спробуємо реалізувати
     найпростіше замикання.
  */

  const ClosureFunc = () =>  {
    let i = 10;
    console.log(i)
    return (arg) => i + arg;
  }

  const AnotherClousureFunc = () => {
    let i = 20;
    // func()() -> Виклик функції, що повертається
    console.log( ClosureFunc()(i) );
  }

  /*
    Чому так відбувається?
     Функція ClosureFunc при ініціалізації зберігає значення змінної i.
     Так само при поверненні результату – функція яку ми повертаємо буде
     посилаються на це значення.
     Тобто значення змінної замикається в межах функції в якій вона була
     оголошено.
  */
  AnotherClousureFunc();

  /*
    Таке що таке замикання?
     Замикання це комбінація функції та лексичного оточення в якому
     ця функція була оголошена.
  */
}

document.addEventListener('DOMContentLoaded', Demo);
